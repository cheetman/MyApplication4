package com.example.sychiprpclibmcc.rpc;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;import java.security.cert.CertificateException;import java.security.cert.X509Certificate;import java.util.Calendar;import java.util.Timer;import javax.net.ssl.SSLContext;import javax.net.ssl.SSLSocketFactory;import javax.net.ssl.TrustManager;import javax.net.ssl.X509TrustManager;/** *  * Title: SslSocketKit <br> * Description: Rpc Server communication kit<br> * Copyright: SyChip Electronic Technology (Shanghai) Ltd.A subsidiary of * muRata. All Rights Reserved. <br> *  *  * @author SyChip * @version 0.0.01 *  */public class SslSocketKit {	private static int keepLiveSeconds = 15;	final int CONNECT_TIMEOUT = 10;	public boolean isBeginkeepAlive = false;	public static String keepAliveStr;	public String utf8 = "UTF-8";	final int byte1024 = 1024;	private static Calendar lastResponseDateTime;	public static LogIf log = new LogDefault();	public static boolean showLog = false;	/** * Title: ConnectTask <br> * Description: listen connect is timeout or not<br>	 *	 */	private static final class ConnectTask extends java.util.TimerTask {		@Override		public void run() {			readListener.connectedCallBack(false);			instance = null;			this.cancel();		}	}	/** * Title: KeepAliveTask <br> * Description: KeepAliveTask send "OK" to server for keep alive<br>	 *	 */	private static final class KeepAliveTask extends java.util.TimerTask {		@Override		public void run() {			if(SslSocketKit.getInstance() != null && SslSocketKit.isConnected()){		 				  // Get the represented date in milliseconds		        long time1 = lastResponseDateTime.getTimeInMillis();		        long time2 = Calendar.getInstance().getTimeInMillis();		        // Calculate difference in milliseconds		        long diff = time2 - time1;		        try{				if(diff >= 3 * keepLiveSeconds * 1000){					SslSocketKit.getInstance().disconnect();					return;				}		        }catch(Exception e){		        	e.printStackTrace();		        	if (showLog) {						log.logExecption(e);					}		        }		        				SslSocketKit.getInstance().writeSocketData(keepAliveStr);			}		}	}		/**	 * Create a keepAliveTask to keep alive	 * @param _keepLiveSeconds _keepLiveSeconds	 * @param _keepAliveStr _keepAliveStr	 */	public void beginKeepAlive(int _keepLiveSeconds,String _keepAliveStr) {		isBeginkeepAlive = true;		keepLiveSeconds = _keepLiveSeconds;		keepAliveStr = _keepAliveStr;		if (timerKeepAlive == null) {			timerKeepAlive = new Timer();			keepAliveTask= new KeepAliveTask();			timerKeepAlive.schedule(keepAliveTask, keepLiveSeconds * 1000, keepLiveSeconds * 1000);		}	}	private static String ip;	private static int port;	private static Timer timerCon;	private static Timer timerKeepAlive;	private static Socket socket;	private static SslSocketKit instance;	private static SslSocketReadIf readListener;	private static ConnectTask connectTask = new ConnectTask();	private static KeepAliveTask keepAliveTask;	/**	 * get SslSocketKit instance 	 * @return SslSocketKit instance 	 */	public static SslSocketKit getInstance() {		return instance;	}	/**	 * check SslSocketKit is connected or not	 * @return true or false	 */	public static boolean isConnected() {		if (instance == null || socket == null) {			return false;		}		return socket.isConnected();	}	/**	 * create connect and startup time task for connect	 * @param _ip _ip	 * @param _port _port	 * @param readListener readListener	 */	public static void connect(String _ip, int _port,			SslSocketReadIf readListener) {		// connect		ip = _ip;		port = _port;		if (!isConnected()) {			instance = new SslSocketKit(ip, port, readListener);		}		//if connected notice RpcCommand		readListener.connectedCallBack(isConnected());		// close connectTask		if(connectTask != null){			connectTask.cancel();			connectTask = null;		}		if(timerCon != null){			timerCon.cancel();			timerCon = null;		}	}	/**	 * disconnect	 * @return true or false	 */	public synchronized boolean disconnect(boolean errorCallBack) {		try {			// close keepAliveTask			isBeginkeepAlive = false;			if(keepAliveTask != null){				keepAliveTask.cancel();				keepAliveTask= null;			}			// close connectTask			if(timerCon != null){				timerCon.cancel();				timerCon= null;			}			if(timerKeepAlive != null){				timerKeepAlive.cancel();				timerKeepAlive= null;			}			if(connectTask != null){				connectTask.cancel();				connectTask= null;			}			// close socket			if (socket != null) {				if (!socket.isClosed()) {					try {						InputStream in = socket.getInputStream();						OutputStream out = socket.getOutputStream();						if (in != null) {							in.close();						}						if (out != null) {							out.close();						}						if(socket != null){							socket.close();						}					} catch (IOException e) {						e.printStackTrace();					}				}				return true;			}		} catch (Exception e) {        	if (showLog) {				log.logExecption(e);			}			e.printStackTrace();		} finally {			instance = null;			socket = null;			if(errorCallBack){				readListener.errorCallBack(new Exception(ErrorType.DisConnected.toString()),						ErrorType.DisConnected);			}		}		return false;	}		/**	 * disconnect	 * @return true or false	 */	public synchronized boolean disconnect() {		return disconnect(true);	}	/**	 * generate SslSocketKit instance	 * @param ip	 * @param port	 * @param readif	 */	private SslSocketKit(String ip, int port, final SslSocketReadIf readif) {		isBeginkeepAlive = false;		readListener = readif;		if (socket == null) {			try {				SSLContext sslContext = SSLContext.getInstance("TLS");				sslContext.init(null,						new TrustManager[] { new RpcTrustManager() }, null);				SSLSocketFactory socketFactory = sslContext.getSocketFactory();				//Startup a timer to listen connect is time or not				if (timerCon == null) {					timerCon = new Timer();					connectTask = new ConnectTask();					timerCon.schedule(connectTask, CONNECT_TIMEOUT * 1000);				}				socket = socketFactory.createSocket(ip, port);				System.out.println("连接成功");				//Start up a thread to listen socket output				new Thread() {					public void run() {						try {							String str = "";							int c = socket.getInputStream().read();							ByteArrayOutputStream os = new ByteArrayOutputStream(byte1024);							while (c != -1) {								lastResponseDateTime = Calendar.getInstance();								if (c == 0) {									str = new String(os.toByteArray(),utf8);//									if (showLog) {//										log.logOut("Response Json:"+str);//									}									RpcCommand.getInstance().readDataCallBack(str);									str = "";									os = new ByteArrayOutputStream(byte1024);								}								if (c != 0) {									os.write(c);								}								c = socket.getInputStream().read();							}							disconnect();						} catch (Exception e) {				        	if (showLog) {								log.logExecption(e);							}							disconnect();						}					}				}.start();			} catch (Exception e) {				e.printStackTrace();	        	if (showLog) {					log.logExecption(e);				}			}		}	}	/**	 * for RpcCommand to write data to socket	 * @param reqStr string to write	 */	public synchronized void sendSocketData(final String reqStr) {		new Thread() {			public void run() {				writeSocketData(reqStr);				if (showLog) {					log.logOut("Request Json:"+reqStr);				}			}		}.start();	}	/**	 * write data to socket	 * @param reqStr	 * @param logParam	 */	private synchronized void writeSocketData(final String reqStr) {		if (!isConnected()) {			readListener.errorCallBack(new Exception(ErrorType.DisConnected.toString()), ErrorType.DisConnected);		} else {			try {				byte[] bytes = (reqStr + "\0").getBytes(utf8);				socket.getOutputStream().write(bytes);			} catch (Exception e) {				//因为断开连接会有处理，所以这边写不出去最终会timeout，这里可以不用处理exception				e.printStackTrace();				if (showLog) {					log.logOut(">>>>>>因为断开连接会有处理，所以这边写不出去最终会timeout，这里不用处理exception");					log.logExecption(e);					log.logOut("<<<<<<<<<<<<<");				}			}//			try {//				//when there are new socket input,reset keepAliveTask.//				if(timerKeepAlive != null){//					timerKeepAlive.cancel();//				}//				if(keepAliveTask != null){//					keepAliveTask.cancel();//				}//				keepAliveTask = null;//				timerKeepAlive = null;//				if(isBeginkeepAlive){//					keepAliveTask = new KeepAliveTask();//					timerKeepAlive = new Timer();//					timerKeepAlive.schedule(keepAliveTask, this.keepLiveSeconds * 1000, this.keepLiveSeconds * 1000);//				}//			} catch (Exception e) {//				e.printStackTrace();//			}		}	}	/**	 * SslSocket data read interface	 * 	 * @author sychip	 * 	 */	public interface SslSocketReadIf {		/**		 * SslSocket data read callback		 * 		 * @param resp resp		 */		void readDataCallBack(String resp);		/**		 * SslSocket connected callback		 * 		 * @param isConnected isConnected		 */		void connectedCallBack(boolean isConnected);		/**		 * SslSocket disconnectedCallBack callback		 * 		 */		void disconnectedCallBack();		/**		 * SslSocket connected callback		 * 		 * @param ex ex		 * @param exType exType		 * @see ErrorType		 */		void errorCallBack(Exception ex, ErrorType exType);	}				public final class RpcTrustManager implements X509TrustManager {		X509Certificate[] acceptedIssuers = new X509Certificate[] {};		@Override		public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {		}		public boolean isClientTrusted(X509Certificate[] chain) {			return true;		}		public boolean isServerTrusted(X509Certificate[] chain) {			return true;		}		@Override		public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {		}		@Override		public X509Certificate[] getAcceptedIssuers() {			return acceptedIssuers;		}	}}